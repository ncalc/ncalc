//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.2 NCalc.g 2021-12-17 16:41:36

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System;
using System.Text;
using System.Globalization;
using NCalc.Domain;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  NCalc 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.2")]
[System.CLSCompliant(false)]
public partial class NCalcParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "A", "AND", "B", "C", "D", "DATETIME", "DIGIT", "E", "EXPONENT", "EscapeSequence", "F", "FALSE", "FLOAT", "G", "H", "HexDigit", "I", "ID", "INTEGER", "J", "K", "L", "LETTER", "M", "N", "NAME", "NOT", "O", "OR", "P", "Q", "R", "S", "STRING", "T", "TRUE", "U", "UnicodeEscape", "V", "W", "WS", "X", "Y", "Z", "'!'", "'!='", "'%'", "'&&'", "'&'", "'('", "')'", "'*'", "'**'", "'+'", "','", "'-'", "'/'", "':'", "'<'", "'<<'", "'<='", "'<>'", "'='", "'=='", "'>'", "'>='", "'>>'", "'?'", "'^'", "'|'", "'||'", "'~'"
	};
	public const int EOF=-1;
	public const int A=4;
	public const int AND=5;
	public const int B=6;
	public const int C=7;
	public const int D=8;
	public const int DATETIME=9;
	public const int DIGIT=10;
	public const int E=11;
	public const int EXPONENT=12;
	public const int EscapeSequence=13;
	public const int F=14;
	public const int FALSE=15;
	public const int FLOAT=16;
	public const int G=17;
	public const int H=18;
	public const int HexDigit=19;
	public const int I=20;
	public const int ID=21;
	public const int INTEGER=22;
	public const int J=23;
	public const int K=24;
	public const int L=25;
	public const int LETTER=26;
	public const int M=27;
	public const int N=28;
	public const int NAME=29;
	public const int NOT=30;
	public const int O=31;
	public const int OR=32;
	public const int P=33;
	public const int Q=34;
	public const int R=35;
	public const int S=36;
	public const int STRING=37;
	public const int T=38;
	public const int TRUE=39;
	public const int U=40;
	public const int UnicodeEscape=41;
	public const int V=42;
	public const int W=43;
	public const int WS=44;
	public const int X=45;
	public const int Y=46;
	public const int Z=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int T__74=74;
	public const int T__75=75;

	public NCalcParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public NCalcParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return NCalcParser.tokenNames; } }
	public override string GrammarFileName { get { return "NCalc.g"; } }


	private const char BS = '\\';
	private static NumberFormatInfo numberFormatInfo = new NumberFormatInfo();

	private string extractString(string text) {
	    
	    StringBuilder sb = new StringBuilder(text);
	    int startIndex = 1; // Skip initial quote
	    int slashIndex = -1;

	    while ((slashIndex = sb.ToString().IndexOf(BS, startIndex)) != -1)
	    {
	        char escapeType = sb[slashIndex + 1];
	        switch (escapeType)
	        {
	            case 'u':
	              string hcode = String.Concat(sb[slashIndex+4], sb[slashIndex+5]);
	              string lcode = String.Concat(sb[slashIndex+2], sb[slashIndex+3]);
	              char unicodeChar = Encoding.Unicode.GetChars(new byte[] { System.Convert.ToByte(hcode, 16), System.Convert.ToByte(lcode, 16)} )[0];
	              sb.Remove(slashIndex, 6).Insert(slashIndex, unicodeChar); 
	              break;
	            case 'n': sb.Remove(slashIndex, 2).Insert(slashIndex, '\n'); break;
	            case 'r': sb.Remove(slashIndex, 2).Insert(slashIndex, '\r'); break;
	            case 't': sb.Remove(slashIndex, 2).Insert(slashIndex, '\t'); break;
	            case '\'': sb.Remove(slashIndex, 2).Insert(slashIndex, '\''); break;
	            case '\\': sb.Remove(slashIndex, 2).Insert(slashIndex, '\\'); break;
	            default: throw new RecognitionException("Unvalid escape sequence: \\" + escapeType);
	        }

	        startIndex = slashIndex + 1;

	    }

	    sb.Remove(0, 1);
	    sb.Remove(sb.Length - 1, 1);

	    return sb.ToString();
	}

	public List<string> Errors { get; private set; }

	public override void DisplayRecognitionError(String[] tokenNames, RecognitionException e) {
	    
	    base.DisplayRecognitionError(tokenNames, e);
	    
	    if(Errors == null)
	    {
	    	Errors = new List<string>();
	    }
	    
	    String hdr = GetErrorHeader(e);
	    String msg = GetErrorMessage(e, tokenNames);
	    Errors.Add(msg + " at " + hdr);
	}

	public LogicalExpression GetExpression() => ncalcExpression().value;



	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	private sealed partial class ncalcExpression_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public LogicalExpression value;
		public ncalcExpression_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_ncalcExpression();
	partial void LeaveRule_ncalcExpression();
	// $ANTLR start "ncalcExpression"
	// NCalc.g:83:1: ncalcExpression returns [LogicalExpression value] : logicalExpression EOF !;
	[GrammarRule("ncalcExpression")]
	private NCalcParser.ncalcExpression_return ncalcExpression()
	{
		EnterRule_ncalcExpression();
		EnterRule("ncalcExpression", 1);
		TraceIn("ncalcExpression", 1);
		NCalcParser.ncalcExpression_return retval = new NCalcParser.ncalcExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken EOF2 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> logicalExpression1 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree EOF2_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "ncalcExpression");
		DebugLocation(83, 1);
		try
		{
			// NCalc.g:84:2: ( logicalExpression EOF !)
			DebugEnterAlt(1);
			// NCalc.g:84:4: logicalExpression EOF !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(84, 4);
			PushFollow(Follow._logicalExpression_in_ncalcExpression73);
			logicalExpression1=logicalExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalExpression1.Tree);
			DebugLocation(84, 25);
			EOF2=(IToken)Match(input,EOF,Follow._EOF_in_ncalcExpression75); 
			DebugLocation(84, 27);
			retval.value = (logicalExpression1!=null?((NCalcParser.logicalExpression_return)logicalExpression1).value:default(LogicalExpression)); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ncalcExpression", 1);
			LeaveRule("ncalcExpression", 1);
			LeaveRule_ncalcExpression();
		}
		DebugLocation(85, 1);
		} finally { DebugExitRule(GrammarFileName, "ncalcExpression"); }
		return retval;

	}
	// $ANTLR end "ncalcExpression"

	private sealed partial class logicalExpression_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public LogicalExpression value;
		public logicalExpression_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_logicalExpression();
	partial void LeaveRule_logicalExpression();
	// $ANTLR start "logicalExpression"
	// NCalc.g:87:1: logicalExpression returns [LogicalExpression value] : left= conditionalExpression ( '?' middle= conditionalExpression ':' right= conditionalExpression )? ;
	[GrammarRule("logicalExpression")]
	private NCalcParser.logicalExpression_return logicalExpression()
	{
		EnterRule_logicalExpression();
		EnterRule("logicalExpression", 2);
		TraceIn("logicalExpression", 2);
		NCalcParser.logicalExpression_return retval = new NCalcParser.logicalExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal3 = default(IToken);
		IToken char_literal4 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> left = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> middle = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> right = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal3_tree = default(CommonTree);
		CommonTree char_literal4_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "logicalExpression");
		DebugLocation(87, 1);
		try
		{
			// NCalc.g:88:2: (left= conditionalExpression ( '?' middle= conditionalExpression ':' right= conditionalExpression )? )
			DebugEnterAlt(1);
			// NCalc.g:88:4: left= conditionalExpression ( '?' middle= conditionalExpression ':' right= conditionalExpression )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(88, 8);
			PushFollow(Follow._conditionalExpression_in_logicalExpression95);
			left=conditionalExpression();
			PopFollow();

			adaptor.AddChild(root_0, left.Tree);
			DebugLocation(88, 31);
			 retval.value = (left!=null?((NCalcParser.conditionalExpression_return)left).value:default(LogicalExpression)); 
			DebugLocation(88, 57);
			// NCalc.g:88:57: ( '?' middle= conditionalExpression ':' right= conditionalExpression )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_1 = input.LA(1);

			if ((LA1_1==71))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// NCalc.g:88:59: '?' middle= conditionalExpression ':' right= conditionalExpression
				{
				DebugLocation(88, 59);
				char_literal3=(IToken)Match(input,71,Follow._71_in_logicalExpression101); 
				char_literal3_tree = (CommonTree)adaptor.Create(char_literal3);
				adaptor.AddChild(root_0, char_literal3_tree);
				DebugLocation(88, 69);
				PushFollow(Follow._conditionalExpression_in_logicalExpression105);
				middle=conditionalExpression();
				PopFollow();

				adaptor.AddChild(root_0, middle.Tree);
				DebugLocation(88, 92);
				char_literal4=(IToken)Match(input,61,Follow._61_in_logicalExpression107); 
				char_literal4_tree = (CommonTree)adaptor.Create(char_literal4);
				adaptor.AddChild(root_0, char_literal4_tree);
				DebugLocation(88, 101);
				PushFollow(Follow._conditionalExpression_in_logicalExpression111);
				right=conditionalExpression();
				PopFollow();

				adaptor.AddChild(root_0, right.Tree);
				DebugLocation(88, 124);
				 retval.value = new TernaryExpression((left!=null?((NCalcParser.conditionalExpression_return)left).value:default(LogicalExpression)), (middle!=null?((NCalcParser.conditionalExpression_return)middle).value:default(LogicalExpression)), (right!=null?((NCalcParser.conditionalExpression_return)right).value:default(LogicalExpression))); 

				}
				break;

			}
			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalExpression", 2);
			LeaveRule("logicalExpression", 2);
			LeaveRule_logicalExpression();
		}
		DebugLocation(89, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalExpression"); }
		return retval;

	}
	// $ANTLR end "logicalExpression"

	private sealed partial class conditionalExpression_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public LogicalExpression value;
		public conditionalExpression_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_conditionalExpression();
	partial void LeaveRule_conditionalExpression();
	// $ANTLR start "conditionalExpression"
	// NCalc.g:91:1: conditionalExpression returns [LogicalExpression value] : left= booleanAndExpression ( ( '||' | OR ) right= conditionalExpression )* ;
	[GrammarRule("conditionalExpression")]
	private NCalcParser.conditionalExpression_return conditionalExpression()
	{
		EnterRule_conditionalExpression();
		EnterRule("conditionalExpression", 3);
		TraceIn("conditionalExpression", 3);
		NCalcParser.conditionalExpression_return retval = new NCalcParser.conditionalExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set5 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> left = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> right = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set5_tree = default(CommonTree);

		BinaryExpressionType type = BinaryExpressionType.Unknown;

		try { DebugEnterRule(GrammarFileName, "conditionalExpression");
		DebugLocation(91, 1);
		try
		{
			// NCalc.g:95:2: (left= booleanAndExpression ( ( '||' | OR ) right= conditionalExpression )* )
			DebugEnterAlt(1);
			// NCalc.g:95:4: left= booleanAndExpression ( ( '||' | OR ) right= conditionalExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(95, 8);
			PushFollow(Follow._booleanAndExpression_in_conditionalExpression138);
			left=booleanAndExpression();
			PopFollow();

			adaptor.AddChild(root_0, left.Tree);
			DebugLocation(95, 30);
			 retval.value = (left!=null?((NCalcParser.booleanAndExpression_return)left).value:default(LogicalExpression)); 
			DebugLocation(95, 56);
			// NCalc.g:95:56: ( ( '||' | OR ) right= conditionalExpression )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1==OR||LA2_1==74))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// NCalc.g:96:4: ( '||' | OR ) right= conditionalExpression
					{
					DebugLocation(96, 4);

					set5=(IToken)input.LT(1);
					if (input.LA(1)==OR||input.LA(1)==74)
					{
						input.Consume();
						adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set5));
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(96, 16);
					 type = BinaryExpressionType.Or; 
					DebugLocation(97, 9);
					PushFollow(Follow._conditionalExpression_in_conditionalExpression163);
					right=conditionalExpression();
					PopFollow();

					adaptor.AddChild(root_0, right.Tree);
					DebugLocation(97, 32);
					 retval.value = new BinaryExpression(type, retval.value, (right!=null?((NCalcParser.conditionalExpression_return)right).value:default(LogicalExpression))); 

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionalExpression", 3);
			LeaveRule("conditionalExpression", 3);
			LeaveRule_conditionalExpression();
		}
		DebugLocation(99, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionalExpression"); }
		return retval;

	}
	// $ANTLR end "conditionalExpression"

	private sealed partial class booleanAndExpression_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public LogicalExpression value;
		public booleanAndExpression_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_booleanAndExpression();
	partial void LeaveRule_booleanAndExpression();
	// $ANTLR start "booleanAndExpression"
	// NCalc.g:101:1: booleanAndExpression returns [LogicalExpression value] : left= bitwiseOrExpression ( ( '&&' | AND ) right= bitwiseOrExpression )* ;
	[GrammarRule("booleanAndExpression")]
	private NCalcParser.booleanAndExpression_return booleanAndExpression()
	{
		EnterRule_booleanAndExpression();
		EnterRule("booleanAndExpression", 4);
		TraceIn("booleanAndExpression", 4);
		NCalcParser.booleanAndExpression_return retval = new NCalcParser.booleanAndExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set6 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> left = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> right = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set6_tree = default(CommonTree);

		BinaryExpressionType type = BinaryExpressionType.Unknown;

		try { DebugEnterRule(GrammarFileName, "booleanAndExpression");
		DebugLocation(101, 1);
		try
		{
			// NCalc.g:105:2: (left= bitwiseOrExpression ( ( '&&' | AND ) right= bitwiseOrExpression )* )
			DebugEnterAlt(1);
			// NCalc.g:105:4: left= bitwiseOrExpression ( ( '&&' | AND ) right= bitwiseOrExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(105, 8);
			PushFollow(Follow._bitwiseOrExpression_in_booleanAndExpression197);
			left=bitwiseOrExpression();
			PopFollow();

			adaptor.AddChild(root_0, left.Tree);
			DebugLocation(105, 29);
			 retval.value = (left!=null?((NCalcParser.bitwiseOrExpression_return)left).value:default(LogicalExpression)); 
			DebugLocation(105, 55);
			// NCalc.g:105:55: ( ( '&&' | AND ) right= bitwiseOrExpression )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==AND||LA3_1==51))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// NCalc.g:106:4: ( '&&' | AND ) right= bitwiseOrExpression
					{
					DebugLocation(106, 4);

					set6=(IToken)input.LT(1);
					if (input.LA(1)==AND||input.LA(1)==51)
					{
						input.Consume();
						adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set6));
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(106, 17);
					 type = BinaryExpressionType.And; 
					DebugLocation(107, 9);
					PushFollow(Follow._bitwiseOrExpression_in_booleanAndExpression222);
					right=bitwiseOrExpression();
					PopFollow();

					adaptor.AddChild(root_0, right.Tree);
					DebugLocation(107, 30);
					 retval.value = new BinaryExpression(type, retval.value, (right!=null?((NCalcParser.bitwiseOrExpression_return)right).value:default(LogicalExpression))); 

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("booleanAndExpression", 4);
			LeaveRule("booleanAndExpression", 4);
			LeaveRule_booleanAndExpression();
		}
		DebugLocation(109, 1);
		} finally { DebugExitRule(GrammarFileName, "booleanAndExpression"); }
		return retval;

	}
	// $ANTLR end "booleanAndExpression"

	private sealed partial class bitwiseOrExpression_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public LogicalExpression value;
		public bitwiseOrExpression_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_bitwiseOrExpression();
	partial void LeaveRule_bitwiseOrExpression();
	// $ANTLR start "bitwiseOrExpression"
	// NCalc.g:111:1: bitwiseOrExpression returns [LogicalExpression value] : left= bitwiseXOrExpression ( '|' right= bitwiseOrExpression )* ;
	[GrammarRule("bitwiseOrExpression")]
	private NCalcParser.bitwiseOrExpression_return bitwiseOrExpression()
	{
		EnterRule_bitwiseOrExpression();
		EnterRule("bitwiseOrExpression", 5);
		TraceIn("bitwiseOrExpression", 5);
		NCalcParser.bitwiseOrExpression_return retval = new NCalcParser.bitwiseOrExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal7 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> left = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> right = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal7_tree = default(CommonTree);

		BinaryExpressionType type = BinaryExpressionType.Unknown;

		try { DebugEnterRule(GrammarFileName, "bitwiseOrExpression");
		DebugLocation(111, 1);
		try
		{
			// NCalc.g:115:2: (left= bitwiseXOrExpression ( '|' right= bitwiseOrExpression )* )
			DebugEnterAlt(1);
			// NCalc.g:115:4: left= bitwiseXOrExpression ( '|' right= bitwiseOrExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(115, 8);
			PushFollow(Follow._bitwiseXOrExpression_in_bitwiseOrExpression254);
			left=bitwiseXOrExpression();
			PopFollow();

			adaptor.AddChild(root_0, left.Tree);
			DebugLocation(115, 30);
			 retval.value = (left!=null?((NCalcParser.bitwiseXOrExpression_return)left).value:default(LogicalExpression)); 
			DebugLocation(115, 56);
			// NCalc.g:115:56: ( '|' right= bitwiseOrExpression )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==73))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// NCalc.g:116:4: '|' right= bitwiseOrExpression
					{
					DebugLocation(116, 4);
					char_literal7=(IToken)Match(input,73,Follow._73_in_bitwiseOrExpression263); 
					char_literal7_tree = (CommonTree)adaptor.Create(char_literal7);
					adaptor.AddChild(root_0, char_literal7_tree);
					DebugLocation(116, 8);
					 type = BinaryExpressionType.BitwiseOr; 
					DebugLocation(117, 9);
					PushFollow(Follow._bitwiseOrExpression_in_bitwiseOrExpression273);
					right=bitwiseOrExpression();
					PopFollow();

					adaptor.AddChild(root_0, right.Tree);
					DebugLocation(117, 30);
					 retval.value = new BinaryExpression(type, retval.value, (right!=null?((NCalcParser.bitwiseOrExpression_return)right).value:default(LogicalExpression))); 

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseOrExpression", 5);
			LeaveRule("bitwiseOrExpression", 5);
			LeaveRule_bitwiseOrExpression();
		}
		DebugLocation(119, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseOrExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseOrExpression"

	private sealed partial class bitwiseXOrExpression_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public LogicalExpression value;
		public bitwiseXOrExpression_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_bitwiseXOrExpression();
	partial void LeaveRule_bitwiseXOrExpression();
	// $ANTLR start "bitwiseXOrExpression"
	// NCalc.g:121:1: bitwiseXOrExpression returns [LogicalExpression value] : left= bitwiseAndExpression ( '^' right= bitwiseAndExpression )* ;
	[GrammarRule("bitwiseXOrExpression")]
	private NCalcParser.bitwiseXOrExpression_return bitwiseXOrExpression()
	{
		EnterRule_bitwiseXOrExpression();
		EnterRule("bitwiseXOrExpression", 6);
		TraceIn("bitwiseXOrExpression", 6);
		NCalcParser.bitwiseXOrExpression_return retval = new NCalcParser.bitwiseXOrExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal8 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> left = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> right = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal8_tree = default(CommonTree);

		BinaryExpressionType type = BinaryExpressionType.Unknown;

		try { DebugEnterRule(GrammarFileName, "bitwiseXOrExpression");
		DebugLocation(121, 1);
		try
		{
			// NCalc.g:125:2: (left= bitwiseAndExpression ( '^' right= bitwiseAndExpression )* )
			DebugEnterAlt(1);
			// NCalc.g:125:4: left= bitwiseAndExpression ( '^' right= bitwiseAndExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(125, 8);
			PushFollow(Follow._bitwiseAndExpression_in_bitwiseXOrExpression307);
			left=bitwiseAndExpression();
			PopFollow();

			adaptor.AddChild(root_0, left.Tree);
			DebugLocation(125, 30);
			 retval.value = (left!=null?((NCalcParser.bitwiseAndExpression_return)left).value:default(LogicalExpression)); 
			DebugLocation(125, 56);
			// NCalc.g:125:56: ( '^' right= bitwiseAndExpression )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1==72))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// NCalc.g:126:4: '^' right= bitwiseAndExpression
					{
					DebugLocation(126, 4);
					char_literal8=(IToken)Match(input,72,Follow._72_in_bitwiseXOrExpression316); 
					char_literal8_tree = (CommonTree)adaptor.Create(char_literal8);
					adaptor.AddChild(root_0, char_literal8_tree);
					DebugLocation(126, 8);
					 type = BinaryExpressionType.BitwiseXOr; 
					DebugLocation(127, 9);
					PushFollow(Follow._bitwiseAndExpression_in_bitwiseXOrExpression326);
					right=bitwiseAndExpression();
					PopFollow();

					adaptor.AddChild(root_0, right.Tree);
					DebugLocation(127, 31);
					 retval.value = new BinaryExpression(type, retval.value, (right!=null?((NCalcParser.bitwiseAndExpression_return)right).value:default(LogicalExpression))); 

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseXOrExpression", 6);
			LeaveRule("bitwiseXOrExpression", 6);
			LeaveRule_bitwiseXOrExpression();
		}
		DebugLocation(129, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseXOrExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseXOrExpression"

	private sealed partial class bitwiseAndExpression_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public LogicalExpression value;
		public bitwiseAndExpression_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_bitwiseAndExpression();
	partial void LeaveRule_bitwiseAndExpression();
	// $ANTLR start "bitwiseAndExpression"
	// NCalc.g:131:1: bitwiseAndExpression returns [LogicalExpression value] : left= equalityExpression ( '&' right= equalityExpression )* ;
	[GrammarRule("bitwiseAndExpression")]
	private NCalcParser.bitwiseAndExpression_return bitwiseAndExpression()
	{
		EnterRule_bitwiseAndExpression();
		EnterRule("bitwiseAndExpression", 7);
		TraceIn("bitwiseAndExpression", 7);
		NCalcParser.bitwiseAndExpression_return retval = new NCalcParser.bitwiseAndExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal9 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> left = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> right = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal9_tree = default(CommonTree);

		BinaryExpressionType type = BinaryExpressionType.Unknown;

		try { DebugEnterRule(GrammarFileName, "bitwiseAndExpression");
		DebugLocation(131, 1);
		try
		{
			// NCalc.g:135:2: (left= equalityExpression ( '&' right= equalityExpression )* )
			DebugEnterAlt(1);
			// NCalc.g:135:4: left= equalityExpression ( '&' right= equalityExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(135, 8);
			PushFollow(Follow._equalityExpression_in_bitwiseAndExpression358);
			left=equalityExpression();
			PopFollow();

			adaptor.AddChild(root_0, left.Tree);
			DebugLocation(135, 28);
			 retval.value = (left!=null?((NCalcParser.equalityExpression_return)left).value:default(LogicalExpression)); 
			DebugLocation(135, 54);
			// NCalc.g:135:54: ( '&' right= equalityExpression )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==52))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// NCalc.g:136:4: '&' right= equalityExpression
					{
					DebugLocation(136, 4);
					char_literal9=(IToken)Match(input,52,Follow._52_in_bitwiseAndExpression367); 
					char_literal9_tree = (CommonTree)adaptor.Create(char_literal9);
					adaptor.AddChild(root_0, char_literal9_tree);
					DebugLocation(136, 8);
					 type = BinaryExpressionType.BitwiseAnd; 
					DebugLocation(137, 9);
					PushFollow(Follow._equalityExpression_in_bitwiseAndExpression377);
					right=equalityExpression();
					PopFollow();

					adaptor.AddChild(root_0, right.Tree);
					DebugLocation(137, 29);
					 retval.value = new BinaryExpression(type, retval.value, (right!=null?((NCalcParser.equalityExpression_return)right).value:default(LogicalExpression))); 

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseAndExpression", 7);
			LeaveRule("bitwiseAndExpression", 7);
			LeaveRule_bitwiseAndExpression();
		}
		DebugLocation(139, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseAndExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseAndExpression"

	private sealed partial class equalityExpression_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public LogicalExpression value;
		public equalityExpression_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_equalityExpression();
	partial void LeaveRule_equalityExpression();
	// $ANTLR start "equalityExpression"
	// NCalc.g:141:1: equalityExpression returns [LogicalExpression value] : left= relationalExpression ( ( ( '==' | '=' ) | ( '!=' | '<>' ) ) right= relationalExpression )* ;
	[GrammarRule("equalityExpression")]
	private NCalcParser.equalityExpression_return equalityExpression()
	{
		EnterRule_equalityExpression();
		EnterRule("equalityExpression", 8);
		TraceIn("equalityExpression", 8);
		NCalcParser.equalityExpression_return retval = new NCalcParser.equalityExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set10 = default(IToken);
		IToken set11 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> left = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> right = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set10_tree = default(CommonTree);
		CommonTree set11_tree = default(CommonTree);

		BinaryExpressionType type = BinaryExpressionType.Unknown;

		try { DebugEnterRule(GrammarFileName, "equalityExpression");
		DebugLocation(141, 1);
		try
		{
			// NCalc.g:145:2: (left= relationalExpression ( ( ( '==' | '=' ) | ( '!=' | '<>' ) ) right= relationalExpression )* )
			DebugEnterAlt(1);
			// NCalc.g:145:4: left= relationalExpression ( ( ( '==' | '=' ) | ( '!=' | '<>' ) ) right= relationalExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(145, 8);
			PushFollow(Follow._relationalExpression_in_equalityExpression411);
			left=relationalExpression();
			PopFollow();

			adaptor.AddChild(root_0, left.Tree);
			DebugLocation(145, 30);
			 retval.value = (left!=null?((NCalcParser.relationalExpression_return)left).value:default(LogicalExpression)); 
			DebugLocation(145, 56);
			// NCalc.g:145:56: ( ( ( '==' | '=' ) | ( '!=' | '<>' ) ) right= relationalExpression )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1==49||(LA8_1>=65 && LA8_1<=67)))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// NCalc.g:146:4: ( ( '==' | '=' ) | ( '!=' | '<>' ) ) right= relationalExpression
					{
					DebugLocation(146, 4);
					// NCalc.g:146:4: ( ( '==' | '=' ) | ( '!=' | '<>' ) )
					int alt7=2;
					try { DebugEnterSubRule(7);
					try { DebugEnterDecision(7, false);
					int LA7_1 = input.LA(1);

					if (((LA7_1>=66 && LA7_1<=67)))
					{
						alt7 = 1;
					}
					else if ((LA7_1==49||LA7_1==65))
					{
						alt7 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 7, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(7); }
					switch (alt7)
					{
					case 1:
						DebugEnterAlt(1);
						// NCalc.g:146:6: ( '==' | '=' )
						{
						DebugLocation(146, 6);

						set10=(IToken)input.LT(1);
						if ((input.LA(1)>=66 && input.LA(1)<=67))
						{
							input.Consume();
							adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set10));
							state.errorRecovery=false;
						}
						else
						{
							MismatchedSetException mse = new MismatchedSetException(null,input);
							DebugRecognitionException(mse);
							throw mse;
						}

						DebugLocation(146, 20);
						 type = BinaryExpressionType.Equal; 

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// NCalc.g:147:6: ( '!=' | '<>' )
						{
						DebugLocation(147, 6);

						set11=(IToken)input.LT(1);
						if (input.LA(1)==49||input.LA(1)==65)
						{
							input.Consume();
							adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set11));
							state.errorRecovery=false;
						}
						else
						{
							MismatchedSetException mse = new MismatchedSetException(null,input);
							DebugRecognitionException(mse);
							throw mse;
						}

						DebugLocation(147, 21);
						 type = BinaryExpressionType.NotEqual; 

						}
						break;

					}
					} finally { DebugExitSubRule(7); }

					DebugLocation(148, 9);
					PushFollow(Follow._relationalExpression_in_equalityExpression458);
					right=relationalExpression();
					PopFollow();

					adaptor.AddChild(root_0, right.Tree);
					DebugLocation(148, 31);
					 retval.value = new BinaryExpression(type, retval.value, (right!=null?((NCalcParser.relationalExpression_return)right).value:default(LogicalExpression))); 

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityExpression", 8);
			LeaveRule("equalityExpression", 8);
			LeaveRule_equalityExpression();
		}
		DebugLocation(150, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
		return retval;

	}
	// $ANTLR end "equalityExpression"

	private sealed partial class relationalExpression_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public LogicalExpression value;
		public relationalExpression_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_relationalExpression();
	partial void LeaveRule_relationalExpression();
	// $ANTLR start "relationalExpression"
	// NCalc.g:152:1: relationalExpression returns [LogicalExpression value] : left= shiftExpression ( ( '<' | '<=' | '>' | '>=' ) right= shiftExpression )* ;
	[GrammarRule("relationalExpression")]
	private NCalcParser.relationalExpression_return relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 9);
		TraceIn("relationalExpression", 9);
		NCalcParser.relationalExpression_return retval = new NCalcParser.relationalExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal12 = default(IToken);
		IToken string_literal13 = default(IToken);
		IToken char_literal14 = default(IToken);
		IToken string_literal15 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> left = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> right = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal12_tree = default(CommonTree);
		CommonTree string_literal13_tree = default(CommonTree);
		CommonTree char_literal14_tree = default(CommonTree);
		CommonTree string_literal15_tree = default(CommonTree);

		BinaryExpressionType type = BinaryExpressionType.Unknown;

		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(152, 1);
		try
		{
			// NCalc.g:156:2: (left= shiftExpression ( ( '<' | '<=' | '>' | '>=' ) right= shiftExpression )* )
			DebugEnterAlt(1);
			// NCalc.g:156:4: left= shiftExpression ( ( '<' | '<=' | '>' | '>=' ) right= shiftExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(156, 8);
			PushFollow(Follow._shiftExpression_in_relationalExpression491);
			left=shiftExpression();
			PopFollow();

			adaptor.AddChild(root_0, left.Tree);
			DebugLocation(156, 25);
			 retval.value = (left!=null?((NCalcParser.shiftExpression_return)left).value:default(LogicalExpression)); 
			DebugLocation(156, 51);
			// NCalc.g:156:51: ( ( '<' | '<=' | '>' | '>=' ) right= shiftExpression )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_1 = input.LA(1);

				if ((LA10_1==62||LA10_1==64||(LA10_1>=68 && LA10_1<=69)))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// NCalc.g:157:4: ( '<' | '<=' | '>' | '>=' ) right= shiftExpression
					{
					DebugLocation(157, 4);
					// NCalc.g:157:4: ( '<' | '<=' | '>' | '>=' )
					int alt9=4;
					try { DebugEnterSubRule(9);
					try { DebugEnterDecision(9, false);
					switch (input.LA(1))
					{
					case 62:
						{
						alt9 = 1;
						}
						break;
					case 64:
						{
						alt9 = 2;
						}
						break;
					case 68:
						{
						alt9 = 3;
						}
						break;
					case 69:
						{
						alt9 = 4;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 9, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(9); }
					switch (alt9)
					{
					case 1:
						DebugEnterAlt(1);
						// NCalc.g:157:6: '<'
						{
						DebugLocation(157, 6);
						char_literal12=(IToken)Match(input,62,Follow._62_in_relationalExpression502); 
						char_literal12_tree = (CommonTree)adaptor.Create(char_literal12);
						adaptor.AddChild(root_0, char_literal12_tree);
						DebugLocation(157, 10);
						 type = BinaryExpressionType.Lesser; 

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// NCalc.g:158:6: '<='
						{
						DebugLocation(158, 6);
						string_literal13=(IToken)Match(input,64,Follow._64_in_relationalExpression512); 
						string_literal13_tree = (CommonTree)adaptor.Create(string_literal13);
						adaptor.AddChild(root_0, string_literal13_tree);
						DebugLocation(158, 11);
						 type = BinaryExpressionType.LesserOrEqual; 

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// NCalc.g:159:6: '>'
						{
						DebugLocation(159, 6);
						char_literal14=(IToken)Match(input,68,Follow._68_in_relationalExpression523); 
						char_literal14_tree = (CommonTree)adaptor.Create(char_literal14);
						adaptor.AddChild(root_0, char_literal14_tree);
						DebugLocation(159, 10);
						 type = BinaryExpressionType.Greater; 

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// NCalc.g:160:6: '>='
						{
						DebugLocation(160, 6);
						string_literal15=(IToken)Match(input,69,Follow._69_in_relationalExpression533); 
						string_literal15_tree = (CommonTree)adaptor.Create(string_literal15);
						adaptor.AddChild(root_0, string_literal15_tree);
						DebugLocation(160, 11);
						 type = BinaryExpressionType.GreaterOrEqual; 

						}
						break;

					}
					} finally { DebugExitSubRule(9); }

					DebugLocation(161, 9);
					PushFollow(Follow._shiftExpression_in_relationalExpression545);
					right=shiftExpression();
					PopFollow();

					adaptor.AddChild(root_0, right.Tree);
					DebugLocation(161, 26);
					 retval.value = new BinaryExpression(type, retval.value, (right!=null?((NCalcParser.shiftExpression_return)right).value:default(LogicalExpression))); 

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalExpression", 9);
			LeaveRule("relationalExpression", 9);
			LeaveRule_relationalExpression();
		}
		DebugLocation(163, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return retval;

	}
	// $ANTLR end "relationalExpression"

	private sealed partial class shiftExpression_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public LogicalExpression value;
		public shiftExpression_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_shiftExpression();
	partial void LeaveRule_shiftExpression();
	// $ANTLR start "shiftExpression"
	// NCalc.g:165:1: shiftExpression returns [LogicalExpression value] : left= additiveExpression ( ( '<<' | '>>' ) right= additiveExpression )* ;
	[GrammarRule("shiftExpression")]
	private NCalcParser.shiftExpression_return shiftExpression()
	{
		EnterRule_shiftExpression();
		EnterRule("shiftExpression", 10);
		TraceIn("shiftExpression", 10);
		NCalcParser.shiftExpression_return retval = new NCalcParser.shiftExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal16 = default(IToken);
		IToken string_literal17 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> left = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> right = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal16_tree = default(CommonTree);
		CommonTree string_literal17_tree = default(CommonTree);

		BinaryExpressionType type = BinaryExpressionType.Unknown;

		try { DebugEnterRule(GrammarFileName, "shiftExpression");
		DebugLocation(165, 1);
		try
		{
			// NCalc.g:169:2: (left= additiveExpression ( ( '<<' | '>>' ) right= additiveExpression )* )
			DebugEnterAlt(1);
			// NCalc.g:169:4: left= additiveExpression ( ( '<<' | '>>' ) right= additiveExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(169, 8);
			PushFollow(Follow._additiveExpression_in_shiftExpression577);
			left=additiveExpression();
			PopFollow();

			adaptor.AddChild(root_0, left.Tree);
			DebugLocation(169, 28);
			 retval.value = (left!=null?((NCalcParser.additiveExpression_return)left).value:default(LogicalExpression)); 
			DebugLocation(169, 54);
			// NCalc.g:169:54: ( ( '<<' | '>>' ) right= additiveExpression )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if ((LA12_1==63||LA12_1==70))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// NCalc.g:170:4: ( '<<' | '>>' ) right= additiveExpression
					{
					DebugLocation(170, 4);
					// NCalc.g:170:4: ( '<<' | '>>' )
					int alt11=2;
					try { DebugEnterSubRule(11);
					try { DebugEnterDecision(11, false);
					int LA11_1 = input.LA(1);

					if ((LA11_1==63))
					{
						alt11 = 1;
					}
					else if ((LA11_1==70))
					{
						alt11 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(11); }
					switch (alt11)
					{
					case 1:
						DebugEnterAlt(1);
						// NCalc.g:170:6: '<<'
						{
						DebugLocation(170, 6);
						string_literal16=(IToken)Match(input,63,Follow._63_in_shiftExpression588); 
						string_literal16_tree = (CommonTree)adaptor.Create(string_literal16);
						adaptor.AddChild(root_0, string_literal16_tree);
						DebugLocation(170, 11);
						 type = BinaryExpressionType.LeftShift; 

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// NCalc.g:171:6: '>>'
						{
						DebugLocation(171, 6);
						string_literal17=(IToken)Match(input,70,Follow._70_in_shiftExpression598); 
						string_literal17_tree = (CommonTree)adaptor.Create(string_literal17);
						adaptor.AddChild(root_0, string_literal17_tree);
						DebugLocation(171, 11);
						 type = BinaryExpressionType.RightShift; 

						}
						break;

					}
					} finally { DebugExitSubRule(11); }

					DebugLocation(172, 9);
					PushFollow(Follow._additiveExpression_in_shiftExpression610);
					right=additiveExpression();
					PopFollow();

					adaptor.AddChild(root_0, right.Tree);
					DebugLocation(172, 29);
					 retval.value = new BinaryExpression(type, retval.value, (right!=null?((NCalcParser.additiveExpression_return)right).value:default(LogicalExpression))); 

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("shiftExpression", 10);
			LeaveRule("shiftExpression", 10);
			LeaveRule_shiftExpression();
		}
		DebugLocation(174, 1);
		} finally { DebugExitRule(GrammarFileName, "shiftExpression"); }
		return retval;

	}
	// $ANTLR end "shiftExpression"

	private sealed partial class additiveExpression_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public LogicalExpression value;
		public additiveExpression_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();
	// $ANTLR start "additiveExpression"
	// NCalc.g:176:1: additiveExpression returns [LogicalExpression value] : left= multiplicativeExpression ( ( '+' | '-' ) right= multiplicativeExpression )* ;
	[GrammarRule("additiveExpression")]
	private NCalcParser.additiveExpression_return additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 11);
		TraceIn("additiveExpression", 11);
		NCalcParser.additiveExpression_return retval = new NCalcParser.additiveExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal18 = default(IToken);
		IToken char_literal19 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> left = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> right = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal18_tree = default(CommonTree);
		CommonTree char_literal19_tree = default(CommonTree);

		BinaryExpressionType type = BinaryExpressionType.Unknown;

		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(176, 1);
		try
		{
			// NCalc.g:180:2: (left= multiplicativeExpression ( ( '+' | '-' ) right= multiplicativeExpression )* )
			DebugEnterAlt(1);
			// NCalc.g:180:4: left= multiplicativeExpression ( ( '+' | '-' ) right= multiplicativeExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(180, 8);
			PushFollow(Follow._multiplicativeExpression_in_additiveExpression642);
			left=multiplicativeExpression();
			PopFollow();

			adaptor.AddChild(root_0, left.Tree);
			DebugLocation(180, 34);
			 retval.value = (left!=null?((NCalcParser.multiplicativeExpression_return)left).value:default(LogicalExpression)); 
			DebugLocation(180, 60);
			// NCalc.g:180:60: ( ( '+' | '-' ) right= multiplicativeExpression )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_1 = input.LA(1);

				if ((LA14_1==57||LA14_1==59))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// NCalc.g:181:4: ( '+' | '-' ) right= multiplicativeExpression
					{
					DebugLocation(181, 4);
					// NCalc.g:181:4: ( '+' | '-' )
					int alt13=2;
					try { DebugEnterSubRule(13);
					try { DebugEnterDecision(13, false);
					int LA13_1 = input.LA(1);

					if ((LA13_1==57))
					{
						alt13 = 1;
					}
					else if ((LA13_1==59))
					{
						alt13 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(13); }
					switch (alt13)
					{
					case 1:
						DebugEnterAlt(1);
						// NCalc.g:181:6: '+'
						{
						DebugLocation(181, 6);
						char_literal18=(IToken)Match(input,57,Follow._57_in_additiveExpression653); 
						char_literal18_tree = (CommonTree)adaptor.Create(char_literal18);
						adaptor.AddChild(root_0, char_literal18_tree);
						DebugLocation(181, 10);
						 type = BinaryExpressionType.Plus; 

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// NCalc.g:182:6: '-'
						{
						DebugLocation(182, 6);
						char_literal19=(IToken)Match(input,59,Follow._59_in_additiveExpression663); 
						char_literal19_tree = (CommonTree)adaptor.Create(char_literal19);
						adaptor.AddChild(root_0, char_literal19_tree);
						DebugLocation(182, 10);
						 type = BinaryExpressionType.Minus; 

						}
						break;

					}
					} finally { DebugExitSubRule(13); }

					DebugLocation(183, 9);
					PushFollow(Follow._multiplicativeExpression_in_additiveExpression675);
					right=multiplicativeExpression();
					PopFollow();

					adaptor.AddChild(root_0, right.Tree);
					DebugLocation(183, 35);
					 retval.value = new BinaryExpression(type, retval.value, (right!=null?((NCalcParser.multiplicativeExpression_return)right).value:default(LogicalExpression))); 

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("additiveExpression", 11);
			LeaveRule("additiveExpression", 11);
			LeaveRule_additiveExpression();
		}
		DebugLocation(185, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return retval;

	}
	// $ANTLR end "additiveExpression"

	private sealed partial class multiplicativeExpression_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public LogicalExpression value;
		public multiplicativeExpression_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_multiplicativeExpression();
	partial void LeaveRule_multiplicativeExpression();
	// $ANTLR start "multiplicativeExpression"
	// NCalc.g:187:1: multiplicativeExpression returns [LogicalExpression value] : left= unaryExpression ( ( '*' | '/' | '%' ) right= unaryExpression )* ;
	[GrammarRule("multiplicativeExpression")]
	private NCalcParser.multiplicativeExpression_return multiplicativeExpression()
	{
		EnterRule_multiplicativeExpression();
		EnterRule("multiplicativeExpression", 12);
		TraceIn("multiplicativeExpression", 12);
		NCalcParser.multiplicativeExpression_return retval = new NCalcParser.multiplicativeExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal20 = default(IToken);
		IToken char_literal21 = default(IToken);
		IToken char_literal22 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> left = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> right = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal20_tree = default(CommonTree);
		CommonTree char_literal21_tree = default(CommonTree);
		CommonTree char_literal22_tree = default(CommonTree);

		BinaryExpressionType type = BinaryExpressionType.Unknown;

		try { DebugEnterRule(GrammarFileName, "multiplicativeExpression");
		DebugLocation(187, 1);
		try
		{
			// NCalc.g:191:2: (left= unaryExpression ( ( '*' | '/' | '%' ) right= unaryExpression )* )
			DebugEnterAlt(1);
			// NCalc.g:191:4: left= unaryExpression ( ( '*' | '/' | '%' ) right= unaryExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(191, 8);
			PushFollow(Follow._unaryExpression_in_multiplicativeExpression707);
			left=unaryExpression();
			PopFollow();

			adaptor.AddChild(root_0, left.Tree);
			DebugLocation(191, 25);
			 retval.value = (left!=null?((NCalcParser.unaryExpression_return)left).value:default(LogicalExpression)); 
			DebugLocation(191, 51);
			// NCalc.g:191:51: ( ( '*' | '/' | '%' ) right= unaryExpression )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_1 = input.LA(1);

				if ((LA16_1==50||LA16_1==55||LA16_1==60))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// NCalc.g:192:4: ( '*' | '/' | '%' ) right= unaryExpression
					{
					DebugLocation(192, 4);
					// NCalc.g:192:4: ( '*' | '/' | '%' )
					int alt15=3;
					try { DebugEnterSubRule(15);
					try { DebugEnterDecision(15, false);
					switch (input.LA(1))
					{
					case 55:
						{
						alt15 = 1;
						}
						break;
					case 60:
						{
						alt15 = 2;
						}
						break;
					case 50:
						{
						alt15 = 3;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 15, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(15); }
					switch (alt15)
					{
					case 1:
						DebugEnterAlt(1);
						// NCalc.g:192:6: '*'
						{
						DebugLocation(192, 6);
						char_literal20=(IToken)Match(input,55,Follow._55_in_multiplicativeExpression718); 
						char_literal20_tree = (CommonTree)adaptor.Create(char_literal20);
						adaptor.AddChild(root_0, char_literal20_tree);
						DebugLocation(192, 10);
						 type = BinaryExpressionType.Times; 

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// NCalc.g:193:6: '/'
						{
						DebugLocation(193, 6);
						char_literal21=(IToken)Match(input,60,Follow._60_in_multiplicativeExpression728); 
						char_literal21_tree = (CommonTree)adaptor.Create(char_literal21);
						adaptor.AddChild(root_0, char_literal21_tree);
						DebugLocation(193, 10);
						 type = BinaryExpressionType.Div; 

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// NCalc.g:194:6: '%'
						{
						DebugLocation(194, 6);
						char_literal22=(IToken)Match(input,50,Follow._50_in_multiplicativeExpression738); 
						char_literal22_tree = (CommonTree)adaptor.Create(char_literal22);
						adaptor.AddChild(root_0, char_literal22_tree);
						DebugLocation(194, 10);
						 type = BinaryExpressionType.Modulo; 

						}
						break;

					}
					} finally { DebugExitSubRule(15); }

					DebugLocation(195, 9);
					PushFollow(Follow._unaryExpression_in_multiplicativeExpression750);
					right=unaryExpression();
					PopFollow();

					adaptor.AddChild(root_0, right.Tree);
					DebugLocation(195, 26);
					 retval.value = new BinaryExpression(type, retval.value, (right!=null?((NCalcParser.unaryExpression_return)right).value:default(LogicalExpression))); 

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplicativeExpression", 12);
			LeaveRule("multiplicativeExpression", 12);
			LeaveRule_multiplicativeExpression();
		}
		DebugLocation(197, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeExpression"); }
		return retval;

	}
	// $ANTLR end "multiplicativeExpression"

	private sealed partial class unaryExpression_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public LogicalExpression value;
		public unaryExpression_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();
	// $ANTLR start "unaryExpression"
	// NCalc.g:199:1: unaryExpression returns [LogicalExpression value] : ( exponentialExpression | ( '!' | NOT ) exponentialExpression | ( '~' ) exponentialExpression | '-' exponentialExpression | '+' exponentialExpression );
	[GrammarRule("unaryExpression")]
	private NCalcParser.unaryExpression_return unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 13);
		TraceIn("unaryExpression", 13);
		NCalcParser.unaryExpression_return retval = new NCalcParser.unaryExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set24 = default(IToken);
		IToken char_literal26 = default(IToken);
		IToken char_literal28 = default(IToken);
		IToken char_literal30 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> exponentialExpression23 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> exponentialExpression25 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> exponentialExpression27 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> exponentialExpression29 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> exponentialExpression31 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set24_tree = default(CommonTree);
		CommonTree char_literal26_tree = default(CommonTree);
		CommonTree char_literal28_tree = default(CommonTree);
		CommonTree char_literal30_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(199, 4);
		try
		{
			// NCalc.g:200:2: ( exponentialExpression | ( '!' | NOT ) exponentialExpression | ( '~' ) exponentialExpression | '-' exponentialExpression | '+' exponentialExpression )
			int alt17=5;
			try { DebugEnterDecision(17, false);
			switch (input.LA(1))
			{
			case DATETIME:
			case FALSE:
			case FLOAT:
			case ID:
			case INTEGER:
			case NAME:
			case STRING:
			case TRUE:
			case 53:
				{
				alt17 = 1;
				}
				break;
			case NOT:
			case 48:
				{
				alt17 = 2;
				}
				break;
			case 75:
				{
				alt17 = 3;
				}
				break;
			case 59:
				{
				alt17 = 4;
				}
				break;
			case 57:
				{
				alt17 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 17, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// NCalc.g:200:4: exponentialExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(200, 4);
				PushFollow(Follow._exponentialExpression_in_unaryExpression776);
				exponentialExpression23=exponentialExpression();
				PopFollow();

				adaptor.AddChild(root_0, exponentialExpression23.Tree);
				DebugLocation(200, 26);
				 retval.value = (exponentialExpression23!=null?((NCalcParser.exponentialExpression_return)exponentialExpression23).value:default(LogicalExpression)); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// NCalc.g:201:7: ( '!' | NOT ) exponentialExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(201, 7);

				set24=(IToken)input.LT(1);
				if (input.LA(1)==NOT||input.LA(1)==48)
				{
					input.Consume();
					adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set24));
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(201, 19);
				PushFollow(Follow._exponentialExpression_in_unaryExpression794);
				exponentialExpression25=exponentialExpression();
				PopFollow();

				adaptor.AddChild(root_0, exponentialExpression25.Tree);
				DebugLocation(201, 41);
				 retval.value = new UnaryExpression(UnaryExpressionType.Not, (exponentialExpression25!=null?((NCalcParser.exponentialExpression_return)exponentialExpression25).value:default(LogicalExpression))); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// NCalc.g:202:7: ( '~' ) exponentialExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(202, 7);
				// NCalc.g:202:7: ( '~' )
				DebugEnterAlt(1);
				// NCalc.g:202:8: '~'
				{
				DebugLocation(202, 8);
				char_literal26=(IToken)Match(input,75,Follow._75_in_unaryExpression805); 
				char_literal26_tree = (CommonTree)adaptor.Create(char_literal26);
				adaptor.AddChild(root_0, char_literal26_tree);

				}

				DebugLocation(202, 13);
				PushFollow(Follow._exponentialExpression_in_unaryExpression808);
				exponentialExpression27=exponentialExpression();
				PopFollow();

				adaptor.AddChild(root_0, exponentialExpression27.Tree);
				DebugLocation(202, 35);
				 retval.value = new UnaryExpression(UnaryExpressionType.BitwiseNot, (exponentialExpression27!=null?((NCalcParser.exponentialExpression_return)exponentialExpression27).value:default(LogicalExpression))); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// NCalc.g:203:7: '-' exponentialExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(203, 7);
				char_literal28=(IToken)Match(input,59,Follow._59_in_unaryExpression818); 
				char_literal28_tree = (CommonTree)adaptor.Create(char_literal28);
				adaptor.AddChild(root_0, char_literal28_tree);
				DebugLocation(203, 11);
				PushFollow(Follow._exponentialExpression_in_unaryExpression820);
				exponentialExpression29=exponentialExpression();
				PopFollow();

				adaptor.AddChild(root_0, exponentialExpression29.Tree);
				DebugLocation(203, 33);
				 retval.value = new UnaryExpression(UnaryExpressionType.Negate, (exponentialExpression29!=null?((NCalcParser.exponentialExpression_return)exponentialExpression29).value:default(LogicalExpression))); 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// NCalc.g:204:7: '+' exponentialExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(204, 7);
				char_literal30=(IToken)Match(input,57,Follow._57_in_unaryExpression830); 
				char_literal30_tree = (CommonTree)adaptor.Create(char_literal30);
				adaptor.AddChild(root_0, char_literal30_tree);
				DebugLocation(204, 11);
				PushFollow(Follow._exponentialExpression_in_unaryExpression832);
				exponentialExpression31=exponentialExpression();
				PopFollow();

				adaptor.AddChild(root_0, exponentialExpression31.Tree);
				DebugLocation(204, 33);
				 retval.value = new UnaryExpression(UnaryExpressionType.Positive, (exponentialExpression31!=null?((NCalcParser.exponentialExpression_return)exponentialExpression31).value:default(LogicalExpression))); 

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpression", 13);
			LeaveRule("unaryExpression", 13);
			LeaveRule_unaryExpression();
		}
		DebugLocation(205, 4);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return retval;

	}
	// $ANTLR end "unaryExpression"

	private sealed partial class exponentialExpression_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public LogicalExpression value;
		public exponentialExpression_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_exponentialExpression();
	partial void LeaveRule_exponentialExpression();
	// $ANTLR start "exponentialExpression"
	// NCalc.g:207:1: exponentialExpression returns [LogicalExpression value] : left= primaryExpression ( '**' right= unaryExpression )* ;
	[GrammarRule("exponentialExpression")]
	private NCalcParser.exponentialExpression_return exponentialExpression()
	{
		EnterRule_exponentialExpression();
		EnterRule("exponentialExpression", 14);
		TraceIn("exponentialExpression", 14);
		NCalcParser.exponentialExpression_return retval = new NCalcParser.exponentialExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal32 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> left = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> right = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal32_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "exponentialExpression");
		DebugLocation(207, 1);
		try
		{
			// NCalc.g:208:2: (left= primaryExpression ( '**' right= unaryExpression )* )
			DebugEnterAlt(1);
			// NCalc.g:208:5: left= primaryExpression ( '**' right= unaryExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(208, 9);
			PushFollow(Follow._primaryExpression_in_exponentialExpression857);
			left=primaryExpression();
			PopFollow();

			adaptor.AddChild(root_0, left.Tree);
			DebugLocation(208, 28);
			 retval.value = (left!=null?((NCalcParser.primaryExpression_return)left).value:default(LogicalExpression)); 
			DebugLocation(208, 54);
			// NCalc.g:208:54: ( '**' right= unaryExpression )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if ((LA18_1==56))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// NCalc.g:209:4: '**' right= unaryExpression
					{
					DebugLocation(209, 4);
					string_literal32=(IToken)Match(input,56,Follow._56_in_exponentialExpression866); 
					string_literal32_tree = (CommonTree)adaptor.Create(string_literal32);
					adaptor.AddChild(root_0, string_literal32_tree);
					DebugLocation(209, 14);
					PushFollow(Follow._unaryExpression_in_exponentialExpression870);
					right=unaryExpression();
					PopFollow();

					adaptor.AddChild(root_0, right.Tree);
					DebugLocation(209, 31);
					 retval.value = new BinaryExpression(BinaryExpressionType.Exponentiation, retval.value, (right!=null?((NCalcParser.unaryExpression_return)right).value:default(LogicalExpression))); 

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exponentialExpression", 14);
			LeaveRule("exponentialExpression", 14);
			LeaveRule_exponentialExpression();
		}
		DebugLocation(211, 1);
		} finally { DebugExitRule(GrammarFileName, "exponentialExpression"); }
		return retval;

	}
	// $ANTLR end "exponentialExpression"

	private sealed partial class primaryExpression_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public LogicalExpression value;
		public primaryExpression_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_primaryExpression();
	partial void LeaveRule_primaryExpression();
	// $ANTLR start "primaryExpression"
	// NCalc.g:213:1: primaryExpression returns [LogicalExpression value] : ( '(' logicalExpression ')' |expr= value | identifier ( arguments )? );
	[GrammarRule("primaryExpression")]
	private NCalcParser.primaryExpression_return primaryExpression()
	{
		EnterRule_primaryExpression();
		EnterRule("primaryExpression", 15);
		TraceIn("primaryExpression", 15);
		NCalcParser.primaryExpression_return retval = new NCalcParser.primaryExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal33 = default(IToken);
		IToken char_literal35 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expr = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalExpression34 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier36 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> arguments37 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal33_tree = default(CommonTree);
		CommonTree char_literal35_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "primaryExpression");
		DebugLocation(213, 1);
		try
		{
			// NCalc.g:214:2: ( '(' logicalExpression ')' |expr= value | identifier ( arguments )? )
			int alt20=3;
			try { DebugEnterDecision(20, false);
			switch (input.LA(1))
			{
			case 53:
				{
				alt20 = 1;
				}
				break;
			case DATETIME:
			case FALSE:
			case FLOAT:
			case INTEGER:
			case STRING:
			case TRUE:
				{
				alt20 = 2;
				}
				break;
			case ID:
			case NAME:
				{
				alt20 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 20, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// NCalc.g:214:4: '(' logicalExpression ')'
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(214, 4);
				char_literal33=(IToken)Match(input,53,Follow._53_in_primaryExpression893); 
				char_literal33_tree = (CommonTree)adaptor.Create(char_literal33);
				adaptor.AddChild(root_0, char_literal33_tree);
				DebugLocation(214, 8);
				PushFollow(Follow._logicalExpression_in_primaryExpression895);
				logicalExpression34=logicalExpression();
				PopFollow();

				adaptor.AddChild(root_0, logicalExpression34.Tree);
				DebugLocation(214, 26);
				char_literal35=(IToken)Match(input,54,Follow._54_in_primaryExpression897); 
				char_literal35_tree = (CommonTree)adaptor.Create(char_literal35);
				adaptor.AddChild(root_0, char_literal35_tree);
				DebugLocation(214, 31);
				 retval.value = (logicalExpression34!=null?((NCalcParser.logicalExpression_return)logicalExpression34).value:default(LogicalExpression)); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// NCalc.g:215:4: expr= value
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(215, 8);
				PushFollow(Follow._value_in_primaryExpression907);
				expr=value();
				PopFollow();

				adaptor.AddChild(root_0, expr.Tree);
				DebugLocation(215, 16);
				 retval.value = (expr!=null?((NCalcParser.value_return)expr).value:default(ValueExpression)); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// NCalc.g:216:4: identifier ( arguments )?
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(216, 4);
				PushFollow(Follow._identifier_in_primaryExpression915);
				identifier36=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier36.Tree);
				DebugLocation(216, 15);
				retval.value = (LogicalExpression) (identifier36!=null?((NCalcParser.identifier_return)identifier36).value:default(Identifier)); 
				DebugLocation(216, 66);
				// NCalc.g:216:66: ( arguments )?
				int alt19=2;
				try { DebugEnterSubRule(19);
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1==53))
				{
					alt19 = 1;
				}
				} finally { DebugExitDecision(19); }
				switch (alt19)
				{
				case 1:
					DebugEnterAlt(1);
					// NCalc.g:216:67: arguments
					{
					DebugLocation(216, 67);
					PushFollow(Follow._arguments_in_primaryExpression920);
					arguments37=arguments();
					PopFollow();

					adaptor.AddChild(root_0, arguments37.Tree);
					DebugLocation(216, 77);
					retval.value = new Function((identifier36!=null?((NCalcParser.identifier_return)identifier36).value:default(Identifier)), ((arguments37!=null?((NCalcParser.arguments_return)arguments37).value:default(List<LogicalExpression>))).ToArray()); 

					}
					break;

				}
				} finally { DebugExitSubRule(19); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryExpression", 15);
			LeaveRule("primaryExpression", 15);
			LeaveRule_primaryExpression();
		}
		DebugLocation(217, 1);
		} finally { DebugExitRule(GrammarFileName, "primaryExpression"); }
		return retval;

	}
	// $ANTLR end "primaryExpression"

	private sealed partial class value_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public ValueExpression value;
		public value_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_value();
	partial void LeaveRule_value();
	// $ANTLR start "value"
	// NCalc.g:219:1: value returns [ValueExpression value] : ( INTEGER | FLOAT | STRING | DATETIME | TRUE | FALSE );
	[GrammarRule("value")]
	private NCalcParser.value_return value()
	{
		EnterRule_value();
		EnterRule("value", 16);
		TraceIn("value", 16);
		NCalcParser.value_return retval = new NCalcParser.value_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken INTEGER38 = default(IToken);
		IToken FLOAT39 = default(IToken);
		IToken STRING40 = default(IToken);
		IToken DATETIME41 = default(IToken);
		IToken TRUE42 = default(IToken);
		IToken FALSE43 = default(IToken);

		CommonTree INTEGER38_tree = default(CommonTree);
		CommonTree FLOAT39_tree = default(CommonTree);
		CommonTree STRING40_tree = default(CommonTree);
		CommonTree DATETIME41_tree = default(CommonTree);
		CommonTree TRUE42_tree = default(CommonTree);
		CommonTree FALSE43_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "value");
		DebugLocation(219, 1);
		try
		{
			// NCalc.g:220:2: ( INTEGER | FLOAT | STRING | DATETIME | TRUE | FALSE )
			int alt21=6;
			try { DebugEnterDecision(21, false);
			switch (input.LA(1))
			{
			case INTEGER:
				{
				alt21 = 1;
				}
				break;
			case FLOAT:
				{
				alt21 = 2;
				}
				break;
			case STRING:
				{
				alt21 = 3;
				}
				break;
			case DATETIME:
				{
				alt21 = 4;
				}
				break;
			case TRUE:
				{
				alt21 = 5;
				}
				break;
			case FALSE:
				{
				alt21 = 6;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 21, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// NCalc.g:220:5: INTEGER
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(220, 5);
				INTEGER38=(IToken)Match(input,INTEGER,Follow._INTEGER_in_value940); 
				INTEGER38_tree = (CommonTree)adaptor.Create(INTEGER38);
				adaptor.AddChild(root_0, INTEGER38_tree);
				DebugLocation(220, 14);
				 try { retval.value = new ValueExpression(int.Parse((INTEGER38!=null?INTEGER38.Text:default(string)))); } catch(System.OverflowException) { retval.value = new ValueExpression(long.Parse((INTEGER38!=null?INTEGER38.Text:default(string)))); } 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// NCalc.g:221:4: FLOAT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(221, 4);
				FLOAT39=(IToken)Match(input,FLOAT,Follow._FLOAT_in_value948); 
				FLOAT39_tree = (CommonTree)adaptor.Create(FLOAT39);
				adaptor.AddChild(root_0, FLOAT39_tree);
				DebugLocation(221, 11);
				 retval.value = new ValueExpression(double.Parse((FLOAT39!=null?FLOAT39.Text:default(string)), NumberStyles.Float, numberFormatInfo)); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// NCalc.g:222:4: STRING
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(222, 4);
				STRING40=(IToken)Match(input,STRING,Follow._STRING_in_value956); 
				STRING40_tree = (CommonTree)adaptor.Create(STRING40);
				adaptor.AddChild(root_0, STRING40_tree);
				DebugLocation(222, 12);
				 retval.value = new ValueExpression(extractString((STRING40!=null?STRING40.Text:default(string)))); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// NCalc.g:223:5: DATETIME
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(223, 5);
				DATETIME41=(IToken)Match(input,DATETIME,Follow._DATETIME_in_value965); 
				DATETIME41_tree = (CommonTree)adaptor.Create(DATETIME41);
				adaptor.AddChild(root_0, DATETIME41_tree);
				DebugLocation(223, 14);
				 retval.value = new ValueExpression(DateTime.Parse((DATETIME41!=null?DATETIME41.Text:default(string)).Substring(1, (DATETIME41!=null?DATETIME41.Text:default(string)).Length-2))); 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// NCalc.g:224:4: TRUE
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(224, 4);
				TRUE42=(IToken)Match(input,TRUE,Follow._TRUE_in_value972); 
				TRUE42_tree = (CommonTree)adaptor.Create(TRUE42);
				adaptor.AddChild(root_0, TRUE42_tree);
				DebugLocation(224, 10);
				 retval.value = new ValueExpression(true); 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// NCalc.g:225:4: FALSE
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(225, 4);
				FALSE43=(IToken)Match(input,FALSE,Follow._FALSE_in_value980); 
				FALSE43_tree = (CommonTree)adaptor.Create(FALSE43);
				adaptor.AddChild(root_0, FALSE43_tree);
				DebugLocation(225, 11);
				 retval.value = new ValueExpression(false); 

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value", 16);
			LeaveRule("value", 16);
			LeaveRule_value();
		}
		DebugLocation(226, 1);
		} finally { DebugExitRule(GrammarFileName, "value"); }
		return retval;

	}
	// $ANTLR end "value"

	private sealed partial class identifier_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public Identifier value;
		public identifier_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_identifier();
	partial void LeaveRule_identifier();
	// $ANTLR start "identifier"
	// NCalc.g:228:1: identifier returns [Identifier value] : ( ID | NAME );
	[GrammarRule("identifier")]
	private NCalcParser.identifier_return identifier()
	{
		EnterRule_identifier();
		EnterRule("identifier", 17);
		TraceIn("identifier", 17);
		NCalcParser.identifier_return retval = new NCalcParser.identifier_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken ID44 = default(IToken);
		IToken NAME45 = default(IToken);

		CommonTree ID44_tree = default(CommonTree);
		CommonTree NAME45_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "identifier");
		DebugLocation(228, 1);
		try
		{
			// NCalc.g:229:2: ( ID | NAME )
			int alt22=2;
			try { DebugEnterDecision(22, false);
			int LA22_1 = input.LA(1);

			if ((LA22_1==ID))
			{
				alt22 = 1;
			}
			else if ((LA22_1==NAME))
			{
				alt22 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 22, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// NCalc.g:229:5: ID
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(229, 5);
				ID44=(IToken)Match(input,ID,Follow._ID_in_identifier998); 
				ID44_tree = (CommonTree)adaptor.Create(ID44);
				adaptor.AddChild(root_0, ID44_tree);
				DebugLocation(229, 8);
				 retval.value = new Identifier((ID44!=null?ID44.Text:default(string))); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// NCalc.g:230:5: NAME
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(230, 5);
				NAME45=(IToken)Match(input,NAME,Follow._NAME_in_identifier1006); 
				NAME45_tree = (CommonTree)adaptor.Create(NAME45);
				adaptor.AddChild(root_0, NAME45_tree);
				DebugLocation(230, 10);
				 retval.value = new Identifier((NAME45!=null?NAME45.Text:default(string)).Substring(1, (NAME45!=null?NAME45.Text:default(string)).Length-2)); 

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identifier", 17);
			LeaveRule("identifier", 17);
			LeaveRule_identifier();
		}
		DebugLocation(231, 1);
		} finally { DebugExitRule(GrammarFileName, "identifier"); }
		return retval;

	}
	// $ANTLR end "identifier"

	private sealed partial class expressionList_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public List<LogicalExpression> value;
		public expressionList_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_expressionList();
	partial void LeaveRule_expressionList();
	// $ANTLR start "expressionList"
	// NCalc.g:233:1: expressionList returns [List<LogicalExpression> value] : first= logicalExpression ( ',' follow= logicalExpression )* ;
	[GrammarRule("expressionList")]
	private NCalcParser.expressionList_return expressionList()
	{
		EnterRule_expressionList();
		EnterRule("expressionList", 18);
		TraceIn("expressionList", 18);
		NCalcParser.expressionList_return retval = new NCalcParser.expressionList_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal46 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> first = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> follow = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal46_tree = default(CommonTree);

		List<LogicalExpression> expressions = new List<LogicalExpression>();

		try { DebugEnterRule(GrammarFileName, "expressionList");
		DebugLocation(233, 1);
		try
		{
			// NCalc.g:237:2: (first= logicalExpression ( ',' follow= logicalExpression )* )
			DebugEnterAlt(1);
			// NCalc.g:237:4: first= logicalExpression ( ',' follow= logicalExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(237, 9);
			PushFollow(Follow._logicalExpression_in_expressionList1030);
			first=logicalExpression();
			PopFollow();

			adaptor.AddChild(root_0, first.Tree);
			DebugLocation(237, 28);
			expressions.Add((first!=null?((NCalcParser.logicalExpression_return)first).value:default(LogicalExpression)));
			DebugLocation(237, 62);
			// NCalc.g:237:62: ( ',' follow= logicalExpression )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_1 = input.LA(1);

				if ((LA23_1==58))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// NCalc.g:237:64: ',' follow= logicalExpression
					{
					DebugLocation(237, 64);
					char_literal46=(IToken)Match(input,58,Follow._58_in_expressionList1037); 
					char_literal46_tree = (CommonTree)adaptor.Create(char_literal46);
					adaptor.AddChild(root_0, char_literal46_tree);
					DebugLocation(237, 74);
					PushFollow(Follow._logicalExpression_in_expressionList1041);
					follow=logicalExpression();
					PopFollow();

					adaptor.AddChild(root_0, follow.Tree);
					DebugLocation(237, 93);
					expressions.Add((follow!=null?((NCalcParser.logicalExpression_return)follow).value:default(LogicalExpression)));

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }

			DebugLocation(238, 2);
			 retval.value = expressions; 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expressionList", 18);
			LeaveRule("expressionList", 18);
			LeaveRule_expressionList();
		}
		DebugLocation(239, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionList"); }
		return retval;

	}
	// $ANTLR end "expressionList"

	private sealed partial class arguments_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public List<LogicalExpression> value;
		public arguments_return(NCalcParser grammar) {OnCreated(grammar);}
		partial void OnCreated(NCalcParser grammar);
	}

	partial void EnterRule_arguments();
	partial void LeaveRule_arguments();
	// $ANTLR start "arguments"
	// NCalc.g:241:1: arguments returns [List<LogicalExpression> value] : '(' ( expressionList )? ')' ;
	[GrammarRule("arguments")]
	private NCalcParser.arguments_return arguments()
	{
		EnterRule_arguments();
		EnterRule("arguments", 19);
		TraceIn("arguments", 19);
		NCalcParser.arguments_return retval = new NCalcParser.arguments_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal47 = default(IToken);
		IToken char_literal49 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expressionList48 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal47_tree = default(CommonTree);
		CommonTree char_literal49_tree = default(CommonTree);

		retval.value = new List<LogicalExpression>();

		try { DebugEnterRule(GrammarFileName, "arguments");
		DebugLocation(241, 1);
		try
		{
			// NCalc.g:245:2: ( '(' ( expressionList )? ')' )
			DebugEnterAlt(1);
			// NCalc.g:245:4: '(' ( expressionList )? ')'
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(245, 4);
			char_literal47=(IToken)Match(input,53,Follow._53_in_arguments1070); 
			char_literal47_tree = (CommonTree)adaptor.Create(char_literal47);
			adaptor.AddChild(root_0, char_literal47_tree);
			DebugLocation(245, 8);
			// NCalc.g:245:8: ( expressionList )?
			int alt24=2;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			int LA24_1 = input.LA(1);

			if ((LA24_1==DATETIME||(LA24_1>=FALSE && LA24_1<=FLOAT)||(LA24_1>=ID && LA24_1<=INTEGER)||(LA24_1>=NAME && LA24_1<=NOT)||LA24_1==STRING||LA24_1==TRUE||LA24_1==48||LA24_1==53||LA24_1==57||LA24_1==59||LA24_1==75))
			{
				alt24 = 1;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// NCalc.g:245:10: expressionList
				{
				DebugLocation(245, 10);
				PushFollow(Follow._expressionList_in_arguments1074);
				expressionList48=expressionList();
				PopFollow();

				adaptor.AddChild(root_0, expressionList48.Tree);
				DebugLocation(245, 25);
				retval.value = (expressionList48!=null?((NCalcParser.expressionList_return)expressionList48).value:default(List<LogicalExpression>));

				}
				break;

			}
			} finally { DebugExitSubRule(24); }

			DebugLocation(245, 62);
			char_literal49=(IToken)Match(input,54,Follow._54_in_arguments1081); 
			char_literal49_tree = (CommonTree)adaptor.Create(char_literal49);
			adaptor.AddChild(root_0, char_literal49_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arguments", 19);
			LeaveRule("arguments", 19);
			LeaveRule_arguments();
		}
		DebugLocation(246, 1);
		} finally { DebugExitRule(GrammarFileName, "arguments"); }
		return retval;

	}
	// $ANTLR end "arguments"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _logicalExpression_in_ncalcExpression73 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_ncalcExpression75 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionalExpression_in_logicalExpression95 = new BitSet(new ulong[]{0x2UL,0x80UL});
		public static readonly BitSet _71_in_logicalExpression101 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _conditionalExpression_in_logicalExpression105 = new BitSet(new ulong[]{0x2000000000000000UL});
		public static readonly BitSet _61_in_logicalExpression107 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _conditionalExpression_in_logicalExpression111 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _booleanAndExpression_in_conditionalExpression138 = new BitSet(new ulong[]{0x100000002UL,0x400UL});
		public static readonly BitSet _set_in_conditionalExpression147 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _conditionalExpression_in_conditionalExpression163 = new BitSet(new ulong[]{0x100000002UL,0x400UL});
		public static readonly BitSet _bitwiseOrExpression_in_booleanAndExpression197 = new BitSet(new ulong[]{0x8000000000022UL});
		public static readonly BitSet _set_in_booleanAndExpression206 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _bitwiseOrExpression_in_booleanAndExpression222 = new BitSet(new ulong[]{0x8000000000022UL});
		public static readonly BitSet _bitwiseXOrExpression_in_bitwiseOrExpression254 = new BitSet(new ulong[]{0x2UL,0x200UL});
		public static readonly BitSet _73_in_bitwiseOrExpression263 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _bitwiseOrExpression_in_bitwiseOrExpression273 = new BitSet(new ulong[]{0x2UL,0x200UL});
		public static readonly BitSet _bitwiseAndExpression_in_bitwiseXOrExpression307 = new BitSet(new ulong[]{0x2UL,0x100UL});
		public static readonly BitSet _72_in_bitwiseXOrExpression316 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _bitwiseAndExpression_in_bitwiseXOrExpression326 = new BitSet(new ulong[]{0x2UL,0x100UL});
		public static readonly BitSet _equalityExpression_in_bitwiseAndExpression358 = new BitSet(new ulong[]{0x10000000000002UL});
		public static readonly BitSet _52_in_bitwiseAndExpression367 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _equalityExpression_in_bitwiseAndExpression377 = new BitSet(new ulong[]{0x10000000000002UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression411 = new BitSet(new ulong[]{0x2000000000002UL,0xEUL});
		public static readonly BitSet _set_in_equalityExpression422 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _set_in_equalityExpression439 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression458 = new BitSet(new ulong[]{0x2000000000002UL,0xEUL});
		public static readonly BitSet _shiftExpression_in_relationalExpression491 = new BitSet(new ulong[]{0x4000000000000002UL,0x31UL});
		public static readonly BitSet _62_in_relationalExpression502 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _64_in_relationalExpression512 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _68_in_relationalExpression523 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _69_in_relationalExpression533 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _shiftExpression_in_relationalExpression545 = new BitSet(new ulong[]{0x4000000000000002UL,0x31UL});
		public static readonly BitSet _additiveExpression_in_shiftExpression577 = new BitSet(new ulong[]{0x8000000000000002UL,0x40UL});
		public static readonly BitSet _63_in_shiftExpression588 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _70_in_shiftExpression598 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _additiveExpression_in_shiftExpression610 = new BitSet(new ulong[]{0x8000000000000002UL,0x40UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression642 = new BitSet(new ulong[]{0xA00000000000002UL});
		public static readonly BitSet _57_in_additiveExpression653 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _59_in_additiveExpression663 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression675 = new BitSet(new ulong[]{0xA00000000000002UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression707 = new BitSet(new ulong[]{0x1084000000000002UL});
		public static readonly BitSet _55_in_multiplicativeExpression718 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _60_in_multiplicativeExpression728 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _50_in_multiplicativeExpression738 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression750 = new BitSet(new ulong[]{0x1084000000000002UL});
		public static readonly BitSet _exponentialExpression_in_unaryExpression776 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_unaryExpression786 = new BitSet(new ulong[]{0x2000A020618200UL});
		public static readonly BitSet _exponentialExpression_in_unaryExpression794 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _75_in_unaryExpression805 = new BitSet(new ulong[]{0x2000A020618200UL});
		public static readonly BitSet _exponentialExpression_in_unaryExpression808 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _59_in_unaryExpression818 = new BitSet(new ulong[]{0x2000A020618200UL});
		public static readonly BitSet _exponentialExpression_in_unaryExpression820 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _57_in_unaryExpression830 = new BitSet(new ulong[]{0x2000A020618200UL});
		public static readonly BitSet _exponentialExpression_in_unaryExpression832 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExpression_in_exponentialExpression857 = new BitSet(new ulong[]{0x100000000000002UL});
		public static readonly BitSet _56_in_exponentialExpression866 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _unaryExpression_in_exponentialExpression870 = new BitSet(new ulong[]{0x100000000000002UL});
		public static readonly BitSet _53_in_primaryExpression893 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _logicalExpression_in_primaryExpression895 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _54_in_primaryExpression897 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _value_in_primaryExpression907 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_primaryExpression915 = new BitSet(new ulong[]{0x20000000000002UL});
		public static readonly BitSet _arguments_in_primaryExpression920 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTEGER_in_value940 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_value948 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_value956 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DATETIME_in_value965 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRUE_in_value972 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FALSE_in_value980 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_identifier998 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NAME_in_identifier1006 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalExpression_in_expressionList1030 = new BitSet(new ulong[]{0x400000000000002UL});
		public static readonly BitSet _58_in_expressionList1037 = new BitSet(new ulong[]{0xA2100A060618200UL,0x800UL});
		public static readonly BitSet _logicalExpression_in_expressionList1041 = new BitSet(new ulong[]{0x400000000000002UL});
		public static readonly BitSet _53_in_arguments1070 = new BitSet(new ulong[]{0xA6100A060618200UL,0x800UL});
		public static readonly BitSet _expressionList_in_arguments1074 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _54_in_arguments1081 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  NCalc 
